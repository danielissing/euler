# Overview

**Problem link:** [Project Euler Problem 877](https://projecteuler.net/problem=877)  

Explanations below follow the solution generated by ChatGPT (`solution_chat.py`). For this particular problem, Gemini also produced working code that delivers the correct response (even though it's slower).

---

## 1. Problem statement

Define the XOR-product $x \otimes y$ as binary long multiplication where intermediate sums are combined using XOR instead of integer addition.  

We are interested in solutions to the equation:

$$
(a \otimes a) \oplus (2 \otimes a \otimes b) \oplus (b \otimes b) = 5
$$

For integers $(a, b)$ with $0 \leq a \leq b \leq N$.  

Let $X(N)$ be the XOR of all $b$ values from such solutions. 

**Task:** Compute $X(10^{18})$.

---

## 2. High-level strategy

1. Interpret $\otimes$ as **carryless multiplication** of polynomials over GF(2).  
2. Recast the equation into a **norm equation** inside a quadratic extension of GF(2)[x].  
3. Show that the only solutions come from **monomials $t^k$** in this extension.  
4. Extract explicit recurrences for polynomials $A_k, B_k$ giving  
   $a = (1+x) A_k, \quad b = (1+x) B_k$.  
5. Generate $b_k$ values efficiently and XOR all that are $\leq N$.

---

## 3. The math behind the solution

1. **Carryless multiplication as polynomials:**  
   Represent integers as polynomials in $x$ over GF(2). Then  
   $$a \otimes b = f(x) \cdot g(x) \quad (\text{mod 2 coefficients}).$$  

2. **Norm form:**  
   The given equation is equivalent to  
   $$N(f + t g) = (1+x)^2,$$  
   where $t$ satisfies $t^2 + x t + 1 = 0$.

3. **Ring isomorphism:**  
   The extension ring is isomorphic to GF(2)[t, t^{-1}] via $x = t + t^{-1}$,  
   and the norm is $N(w) = w(t) w(t^{-1})$.  
   Only **monomials $t^k$** have norm 1.

4. **Recurrence for coefficients:**  
   Writing $t^n = A_n(x) + t B_n(x)$ yields:
   $$
   A_{n+1} = B_n, \quad B_{n+1} = A_n + x B_n
   $$
   with $A_0=1, B_0=0$.

   Thus each solution has
   $$
   a = (1+x) A_k, \quad b = (1+x) B_k.
   $$

5. **Extracting $b_k$ values:**  
   Since multiplication by $(1+x)$ means  
   $$
   b_k = B_k \oplus (B_k \ll 1).
   $$

   Here $\ll$ is a binary left shift.  
   Degree grows linearly, so $b_k$ exceeds $N$ after only about $\log_2 N$ steps.

---

## 4. Techniques used to increase algorithmic efficiency

- **Polynomial-as-bitmask encoding:**  
  Represent polynomials by integers; XOR is addition, left shift is multiply by $x$.  

- **Tiny recurrence:**  
  Only two variables $A, B$ are carried forward each step.  

- **Early stopping:**  
  Degrees grow with $k$, so loop ends once $b_k > N$. For $N = 10^{18}$ this is just ~60 iterations.  

- **Direct XOR accumulation:**  
  Maintain running XOR of valid $b_k$ values without storing the sequence.  

---
